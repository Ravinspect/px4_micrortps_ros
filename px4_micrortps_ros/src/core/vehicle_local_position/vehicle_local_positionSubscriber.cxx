// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file vehicle_local_positionSubscriber.cpp
 * This file contains the implementation of the subscriber functions.
 *
 * This file was generated by the tool fastcdrgen.
 */

#include <fastrtps/participant/Participant.h>
#include <fastrtps/attributes/ParticipantAttributes.h>
#include <fastrtps/subscriber/Subscriber.h>
#include <fastrtps/attributes/SubscriberAttributes.h>

#include <fastrtps/Domain.h>

#include "vehicle_local_positionSubscriber.h"


using namespace eprosima::fastrtps;
using namespace eprosima::fastrtps::rtps;

vehicle_local_positionSubscriber::vehicle_local_positionSubscriber() : mp_participant(nullptr), mp_subscriber(nullptr) {}

vehicle_local_positionSubscriber::~vehicle_local_positionSubscriber() { Domain::removeParticipant(mp_participant); }

bool vehicle_local_positionSubscriber::init(const ros::NodeHandle& private_nh)
{
    // Create RTPSParticipant

    ParticipantAttributes PParam;
    PParam.rtps.setName("Participant_subscriber"); // You can put the name you want
    mp_participant = Domain::createParticipant(PParam);
    if (mp_participant == nullptr)
    {
        return false;
    }

    // Register the type

    Domain::registerType(mp_participant, static_cast<TopicDataType *>(&myType));

    // Create Subscriber

    SubscriberAttributes Rparam;
    Rparam.topic.topicKind = NO_KEY;
    Rparam.topic.topicDataType = myType.getName(); // Must be registered before the creation of the subscriber
    Rparam.topic.topicName = "vehicle_local_positionPubSubTopic";
    mp_subscriber = Domain::createSubscriber(mp_participant, Rparam, static_cast<SubscriberListener *>(&m_listener));
    if (mp_subscriber == nullptr)
    {
        return false;
    }

    m_listener.nh_ = private_nh;
    m_listener.vehicle_local_position_publisher_ = m_listener.nh_.advertise<px4_msgs::VehicleLocalPosition>("/px4_micrortps_ros/vehicle_local_position/out", 10);

    return true;
}

void vehicle_local_positionSubscriber::SubListener::onSubscriptionMatched(Subscriber *sub, MatchingInfo &info)
{
    (void)sub;

    if (info.status == MATCHED_MATCHING)
    {
        std::cout << "vehicle_local_positionSubscriber Subscriber matched" << std::endl;
    }
    else
    {
        n_matched--;
        std::cout << "Subscriber unmatched" << std::endl;
    }
}


void vehicle_local_positionSubscriber::SubListener::onNewDataMessage(Subscriber *sub)
{
    // Take data
    vehicle_local_position st;

    if (sub->takeNextData(&st, &m_info))
    {
        if (m_info.sampleKind == ALIVE)
        {
            px4_msgs::VehicleLocalPositionPtr msg_ptr(new px4_msgs::VehicleLocalPosition);
            convertUORBToPX4Message(st, msg_ptr); 

            vehicle_local_position_publisher_.publish(msg_ptr);
        }
    }
}

void vehicle_local_positionSubscriber::SubListener::convertUORBToPX4Message(const vehicle_local_position &st, px4_msgs::VehicleLocalPositionPtr & px4_msg_ptr)
{
    px4_msg_ptr->timestamp = st.timestamp_();
    px4_msg_ptr->timestamp_sample = st.timestamp_sample_();
    px4_msg_ptr->xy_valid = st.xy_valid_();
    px4_msg_ptr->z_valid = st.z_valid_();
    px4_msg_ptr->v_xy_valid = st.v_xy_valid_();
    px4_msg_ptr->v_z_valid = st.v_z_valid_();

    // # Position in local NED frame
    px4_msg_ptr->x = st.x_();
    px4_msg_ptr->y = st.y_();
    px4_msg_ptr->z = st.z_();

    // std::cout << "Vehicle Local Position x:  " << px4_msg_ptr->x << ", y:" <<  px4_msg_ptr->y << ", z:" <<  px4_msg_ptr->z << std::endl;

    // # Position reset delta
    px4_msg_ptr->delta_xy[0] = st.delta_xy()[0];
    px4_msg_ptr->delta_xy[1] = st.delta_xy()[1];
    px4_msg_ptr->xy_reset_counter = st.xy_reset_counter_();

    px4_msg_ptr->delta_z = st.delta_z_();
    px4_msg_ptr->z_reset_counter = st.z_reset_counter_();    

    // # Velocity in NED frame
    px4_msg_ptr->vx = st.vx_();
    px4_msg_ptr->vy = st.vy_();
    px4_msg_ptr->vz = st.vz_();
    px4_msg_ptr->z_deriv = st.z_deriv_();

    // # Velocity reset delta
    px4_msg_ptr->delta_vxy[0] = st.delta_vxy()[0];
    px4_msg_ptr->delta_vxy[1] = st.delta_vxy()[1];
    px4_msg_ptr->vxy_reset_counter = st.vxy_reset_counter_();

    px4_msg_ptr->delta_vz = st.delta_vz_();
    px4_msg_ptr->vz_reset_counter = st.vz_reset_counter_();

    // # Acceleration in NED frame
    px4_msg_ptr->ax = st.ax_();
    px4_msg_ptr->ay = st.ay_();
    px4_msg_ptr->az = st.az_();

    px4_msg_ptr->heading = st.heading_();
    px4_msg_ptr->delta_heading = st.delta_heading_();
    px4_msg_ptr->heading_reset_counter = st.heading_reset_counter_();
    //px4_msg_ptr->heading_good_for_control = st.heading_good_for_control_();

    // # Position of reference point (local NED frame origin) in global (GPS / WGS84) frame
    px4_msg_ptr->xy_global = st.xy_global_();
    px4_msg_ptr->z_global =   st.z_global_();
    px4_msg_ptr->ref_timestamp = st.ref_timestamp_();
    px4_msg_ptr->ref_lat = st.ref_lat_();
    px4_msg_ptr->ref_lon = st.ref_lon_();
    px4_msg_ptr->ref_alt = st.ref_alt_();

    // # Distance to surface
    px4_msg_ptr->dist_bottom = st.dist_bottom_();
    px4_msg_ptr->dist_bottom_valid = st.dist_bottom_valid_();
    px4_msg_ptr->dist_bottom_sensor_bitfield = st.dist_bottom_sensor_bitfield_();

    px4_msg_ptr->eph = st.eph_();
    px4_msg_ptr->epv = st.epv_();
    px4_msg_ptr->evh = st.evh_();
    px4_msg_ptr->evv = st.evv_(); 

    // # estimator specified vehicle limits
    px4_msg_ptr->vxy_max = st.vxy_max_(); 
    px4_msg_ptr->vz_max = st.vz_max_();
    px4_msg_ptr->hagl_min = st.hagl_min_();
    px4_msg_ptr->hagl_max = st.hagl_max_();   
}

void vehicle_local_positionSubscriber::run()
{
    std::cout << "Waiting for Data, press Enter to stop the Subscriber. " << std::endl;
    std::cin.ignore();
    std::cout << "Shutting down the Subscriber." << std::endl;
}
